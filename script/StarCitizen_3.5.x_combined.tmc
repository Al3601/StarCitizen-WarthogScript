include "tm/target.tmh";
include "sc_bindings.ttm";

int log_level = 1;
int delay_ms = 100;

alias version = "3.5.0p";

int main()
{
	printf("\x0aStartCitizen %s combined Throttle & Joystick\x0a", &version);
	if (log_level > 0)
		printf("... log_level set to %d (change it to 0 to stop logging)\x0a\x0a", log_level);

	Configure(&HCougar, MODE_EXCLUDED);
	Configure(&JoystickF18, MODE_EXCLUDED);
	Configure(&T16000, MODE_EXCLUDED);
	Configure(&T16000L, MODE_EXCLUDED);
	Configure(&LMFD, MODE_EXCLUDED);
	Configure(&RMFD, MODE_EXCLUDED);
	Configure(&TFRPRudder, MODE_EXCLUDED);
	Configure(&TWCSThrottle, MODE_EXCLUDED);
	Configure(&TFRPHARudder, MODE_EXCLUDED);

	if (Init(&EventHandle))
		return 1;

	SetKBRate(30, 33);
	SetKBLayout(KB_ENG);
	SetShiftButton(&Joystick, S4, &Throttle, FLAPU, FLAPD, 0);

	mapping();
	startup_illumination();
}

int EventHandle(int type, alias o, int x)
{
	if (log_level > 1)
		printf(">> control: %i\x0a", x);

	DefaultMapping(&o, x);
}

// region Private action functions
// REXEC process IDs
int ReverseThrustRIDX = 0x0001;
int AfterburnerRIDX = 0x0002;

int Blink_LED(int led, int blinkrate)
{
	ActKey(KEYON + CHAIN(LED(&Throttle, LED_ONOFF, LED_CURRENT + led), D(blinkrate), LED(&Throttle, LED_ONOFF, LED_CURRENT - led)));
}

int BlinkReverseThrust()
{
	ActKey(KEYON + StopAutoRepeat(ReverseThrustRIDX));
	ActKey(KEYON + REXEC(ReverseThrustRIDX, 800, "Blink_LED(LED5, 400);", RNOSTOP));
}

int BlinkAfterburner()
{
	ActKey(KEYON + StopAutoRepeat(AfterburnerRIDX));
	ActKey(KEYON + REXEC(AfterburnerRIDX, 300, "Blink_LED(LED1, 150);", RNOSTOP));
}
// endregion

// region Function mapping
int mapping()
{

	if (log_level > 0)
		printf("... init mappings:\x0a");

	throttle_maps();
	joystick_maps();
}

int throttle_maps()
{

	if (log_level > 0)
		printf("... add throttle mappings\x0a");

	// keys
	MapKey(&Throttle, SC, CHAIN(PULSE + F10, D(60), PULSE + F10));
	MapKey(&Throttle, MSP, PULSE + 'v');
	MapKey(&Throttle, MSU, 'q');
	MapKey(&Throttle, MSD, 'e');
	MapKey(&Throttle, SPDF, EXEC("BlinkAfterburner();"));
	MapKeyR(&Throttle, SPDF, EXEC("StopAutoRepeat(AfterburnerRIDX);"));
	MapKey(&Throttle, SPDB, 'x');
	MapKey(&Throttle, BSB, CHAIN(ReverseThrust_Toggle, D(), EXEC("BlinkReverseThrust();")));
	MapKeyR(&Throttle, BSB, CHAIN(ReverseThrust_Toggle, D(), EXEC("StopAutoRepeat(ReverseThrustRIDX);")));
	MapKey(&Throttle, CHF, PULSE + 'h');
	MapKey(&Throttle, CHB, PULSE + 'g');
	MapKey(&Throttle, PSF, PULSE + 't');
	MapKeyR(&Throttle, PSF, PULSE + 't');
	MapKey(&Throttle, LTB, 'z');
	MapKey(&Throttle, EFLNORM, CHAIN(Power_Toggle, D(), LEDsON, D(), LEDs86));
	MapKeyR(&Throttle, EFLNORM, CHAIN(Power_Toggle, D(), LEDsON, D(), LEDs43));
	MapKey(&Throttle, EFRNORM, CHAIN(TrackIRRecenter_Toggle, D(100), TrackIRPause_Toggle));
	MapKeyR(&Throttle, EFRNORM, CHAIN(D(100), TrackIRPause_Toggle));
	MapKey(&Throttle, EOLMOTOR, PULSE + 'p');
	MapKey(&Throttle, EORMOTOR, PULSE + 'o');
	// turn on engines and send one 'J' in order to deactivate the initially main thrusters inversion (Probably a bug in SC)
	MapKey(&Throttle, APUON, CHAIN(PULSE + 'i', D(30), PULSE + 'j'));

	MapKeyR(&Throttle, APUON, PULSE + 'i');
	MapKey(&Throttle, LDGH, DOWN + 'n');
	MapKeyR(&Throttle, LDGH, UP + 'n');
	MapKeyIOUMD(&Throttle, FLAPD, 0, 0, 0, 0, PULSE + 'm', PULSE + 'm');
	MapKeyRIOUMD(&Throttle, FLAPD, 0, 0, 0, 0, PULSE + 'm', PULSE + 'm');
	MapKey(&Throttle, RDRNRM, PULSE + '/');
	MapKeyR(&Throttle, RDRNRM, PULSE + '/');
	MapKey(&Throttle, APENG, DOWN + 'b');
	MapKeyR(&Throttle, APENG, UP + 'b');
	MapKey(&Throttle, APPAT, PULSE + 'c');
	MapKeyR(&Throttle, APPAT, PULSE + 'c');
	MapKey(&Throttle, EOLIGN, PULSE + 'p');
	MapKey(&Throttle, EORIGN, PULSE + 'o');
	MapKey(&Throttle, IDLELON, CHAIN('x', D(), LED(&Throttle, LED_ONOFF, LED_CURRENT + LED4)));
	MapKeyR(&Throttle, IDLELON, LED(&Throttle, LED_ONOFF, LED_CURRENT - LED4));
	MapKey(&Throttle, CSU, PULSE + F8);
	MapKey(&Throttle, CSD, F5);
	MapKey(&Throttle, CSR, F6);
	MapKey(&Throttle, CSL, F7);

	// axis
	KeyAxis(&Throttle, SCY, '', AXMAP2(LIST(0, 40, 70), F10, 0, F9));
	MapAxis(&Throttle, SCX, DX_XROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);
	SetSCurve(&Throttle, SCX, 0, 30, 0, 2, 0);
	MapAxis(&Throttle, SCY, DX_YROT_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
	SetSCurve(&Throttle, SCY, 0, 40, 0, 2, 0);
	MapAxis(&Throttle, THR_RIGHT, DX_Z_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
	SetJCurve(&Throttle, THR_RIGHT, 70, 50);
	MapAxis(&Throttle, THR_LEFT, DX_ZROT_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
	SetJCurve(&Throttle, THR_LEFT, 70, 50);
	MapAxis(&Throttle, THR_FC, DX_SLIDER_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);
	SetJCurve(&Throttle, THR_FC, 50, 50);
}

int joystick_maps()
{

	if (log_level > 0)
		printf("... add joystick mappings\x0a");

	// keys
	MapKey(&Joystick, S3, DOWN + L_ALT);
	MapKeyR(&Joystick, S3, UP + L_ALT);
	MapKey(&Joystick, TG2, CHAIN(DX1, D(), DX2));
	MapKey(&Joystick, H4U, PULSE + '4');
	MapKey(&Joystick, H4R, PULSE + '5');
	MapKey(&Joystick, H4D, '2');
	MapKey(&Joystick, H4L, PULSE + '3');
	MapKey(&Joystick, H4P, '1');
	MapKey(&Joystick, H1U, DOWN + SPC);
	MapKeyR(&Joystick, H1U, UP + SPC);
	MapKey(&Joystick, H1D, DOWN + L_CTL);
	MapKeyR(&Joystick, H1D, UP + L_CTL);
	MapKey(&Joystick, H1L, DOWN + 'a');
	MapKeyR(&Joystick, H1L, UP + 'a');
	MapKey(&Joystick, H1R, DOWN + 'd');
	MapKeyR(&Joystick, H1R, UP + 'd');

	// axis
	MapAxis(&Joystick, JOYX, DX_X_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);
	SetSCurve(&Joystick, JOYX, 0, 0, 0, 2, 0);
	MapAxis(&Joystick, JOYY, DX_Y_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);
	SetSCurve(&Joystick, JOYY, 0, 0, 0, 2, 0);
}
// endregion

// region General functions
int startup_illumination()
{

	if (log_level > 0)
		printf("... illuminate throttle\x0a");

	ActKey(KEYON + LEDsOFF);
	ActKey(KEYON + LEDsON);

	int count = 0;
	ActKey(KEYON + CHAIN(
					   D(),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT + LED5),
					   D(delay_ms * count),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT - LED5),
					   D(),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT + LED4),
					   D(delay_ms * (count + 1)),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT - LED4),
					   D(),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT + LED3),
					   D(delay_ms * (count + 1)),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT - LED3),
					   D(),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT + LED2),
					   D(delay_ms * (count + 1)),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT - LED2),
					   D(),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT + LED1),
					   D(delay_ms * (count + 1)),
					   LED(&Throttle, LED_ONOFF, LED_CURRENT - LED1),
					   LEDs43));
}
// endregion